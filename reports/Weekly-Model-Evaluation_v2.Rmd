---
title: "COVID-19 US Forecast Evaluation Report"
subtitle: "[US COVID-19 Forecast Hub](https://covid19forecasthub.org/) and [Delphi Group](https://delphi.cmu.edu/) Forecast Evaluation Working Group"
author: "(alphabetical order) Jacob Bien, Johannes Bracher, Logan C Brooks, Estee Y Cramer, Jed Grabman, Kate Harwood, Evan L Ray, Nicholas G Reich, Chris Scott" 
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
      
---
<!-- code to run rmarkdown::render(input="./vignettes/covidHubUtils-overview.Rmd") -->

<!-- Code for adding logo at the top -->

<!-- <script> -->
<!--   $(document).ready(function() { -->
<!--     $('#TOC').parent().prepend('<div id=\"nav_logo\"><a href=\"https://covid19forecasthub.org/\" target=\"_blank\"><img src=\"https://github.com/reichlab/covid19-forecast-hub-web/raw/master/images/forecast-hub-logo_DARKBLUE.png\"></a></div>'); -->
<!--   }); -->
<!-- </script> -->

<style>
#nav_logo {
  width: 100%;
  margin-top: 20px;
}

#TOC {
  background: url("https://github.com/reichlab/covid19-forecast-hub-web/raw/master/images/forecast-hub-logo_DARKBLUE-20px-padding.png");
  background-size: contain;
  padding-top: 80px !important;
  background-repeat: no-repeat;
}
</style>
<!-- </style> -->

```{r setup, include=FALSE}
#load libraries
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
library(lubridate)
#library(covidcast)
#library(evalcast)
library(scoringutils)
library(RColorBrewer)
library(DT)
library(surveillance)
library(htmltools)
library(kableExtra)
library(covidHubUtils)
#library(zoltr)
library(plotly)
library(tidyverse)
theme_set(theme_bw())

data("hub_locations")
```

```{r prelim set values}
# the_locations <- hub_locations %>% filter(geo_type == "state") %>%
#   filter(abbreviation %in% datasets::state.abb) %>% pull(fips) #states, us and territories

US_fips <- hub_locations %>%  filter(geo_type == "state") %>% filter(abbreviation %in% datasets::state.abb) %>% pull(fips) #only 50 states 

n_weeks_eval <- 10 #weeks included in evaluation
n_weeks_submitted <- 5 #number of weeks needed for inclusion if no longer submitting
```

```{r get-date-boundaries}
#Important dates used (likely there is a cleaner way to code this)
forecast_mon <- lubridate::floor_date(Sys.Date(), unit = "week") + 1      #Even when running on Tuesday, will be Monday date
last_eval_sat <- as.Date(calc_target_week_end_date(forecast_mon, horizon = 0))
first_eval_sat <- last_eval_sat  - 7*(n_weeks_eval - 1)  #First Evaluated Date

last_submission_date <- last_eval_sat  - 5 #Last submission date
first_submission_date <- first_eval_sat - 11  #First submission date

first_mon_cutoff <- first_eval_sat - 5

last_1wk_target_end_date <- as.Date(calc_target_week_end_date(last_submission_date, horizon = 1)) #last 1 week ahead horizon
first_1wk_target_end_date  <- as.Date(calc_target_week_end_date(first_submission_date, horizon = 0)) #first 1 week ahead horizon

first_4wk_target_end_date  <- as.Date(calc_target_week_end_date(first_submission_date, horizon = 4)) #first horizon with all 4 target weeks evaluated 
last_4wk_target_end_date <- as.Date(calc_target_week_end_date(last_submission_date, horizon = 4))

eval_sat <- c(first_eval_sat, last_eval_sat) #range of dates evaluated 

n_weeks_missing <- 5
```

<!-- ```{r}  -->
<!-- #only use after writing truth data for the day  -->
<!-- truth_dat_case <- read.csv("truth_dat_case.csv") %>% mutate(target_end_date = as.Date(target_end_date)) -->
<!-- truth_dat_inc <- read.csv("truth_dat_inc.csv") %>% mutate(target_end_date = as.Date(target_end_date)) -->
<!-- ``` -->


```{r}
# score_case_edit_all <- read.csv("score_case_edit.csv") %>%
#   mutate(target_end_date = as.Date(target_end_date),
#          forecast_date = as.Date(forecast_date),
#          submission_sat = as.Date(submission_sat),
#          horizon = as.factor(horizon)) %>%
#   filter(!model %in% c("CU-scenario_high","CU-scenario_mid","CU-scenario_low","CU-nochange"))
# 
# score_inc_edit_all <- read.csv("score_inc_edit.csv") %>%
#   mutate(target_end_date = as.Date(target_end_date),
#          forecast_date = as.Date(forecast_date),
#          submission_sat = as.Date(submission_sat),
#          horizon = as.factor(horizon)) %>%
#   filter(!model %in% c("CU-scenario_high","CU-scenario_mid","CU-scenario_low","CU-nochange"))
```

```{r load data}
#load files generated in query-scores-weekly-report.R
load(file = "truth_dat_case.rda")
load(file = "truth_dat_inc.rda")

load(file = "score_case_all.rda") 
load(file = "score_inc_all.rda") 
```

```{r inclusion in leaderboard recent}
#Filtered to include only models in scoreboard (coverage table)
score_case_leaderboard <- score_case_all %>%
  filter(n_weeks >= n_weeks_submitted |  n_weeks_3wksPrior >= 2) %>% 
  filter(!is.na(score_value)) 
# %>%
#   filter(!model %in% c("CU-scenario_high","CU-scenario_mid","CU-scenario_low","CU-nochange"))

#Filtered to include only models in scoreboard (coverage table)
score_inc_leaderboard <- score_inc_all %>%
  filter(n_weeks >= n_weeks_submitted |  n_weeks_3wksPrior >= 2) %>% #filter if missing more than half of forecasts or if missing more than 2 forecasts in the last 3 weeks 
  filter(!is.na(score_value)) 
# %>%
#   filter(!model %in% c("CU-scenario_high","CU-scenario_mid","CU-scenario_low","CU-nochange"))
```

```{r only 10 weeks back}
#filter for 10 weeks back accuracy table
score_case_10wks <- score_case_all %>%
  filter(!is.na(score_value)) %>% 
  filter(target_end_date >= first_eval_sat) %>%
  group_by(model, score_name) %>% 
  mutate(n_forecasts_wis = sum(score_name == "wis"),
         n_forecasts_mae = sum(score_name == "abs_error")) %>% ungroup() %>%
  filter(n_forecasts_wis >= (max(n_forecasts_wis)*0.5) | n_forecasts_mae >= (max(n_forecasts_mae)*0.5)) %>% 
  #filter(!model %in% c("CU-scenario_high","CU-scenario_mid","CU-scenario_low","CU-nochange")) %>%
  droplevels()

#filter for 10 weeks back accuracy table
score_inc_10wks <- score_inc_all %>%
  filter(!is.na(score_value)) %>% 
  filter(target_end_date >= first_eval_sat) %>%
  group_by(model, score_name) %>% mutate(n_forecasts_wis = sum(score_name == "wis" & !is.na(score_value)),
                                         n_forecasts_mae = sum(score_name == "abs_error" & !is.na(score_value))) %>% ungroup() %>%
  filter(n_forecasts_wis >= (max(n_forecasts_wis)*0.5) | n_forecasts_mae >= (max(n_forecasts_mae)*0.5)) %>% 
 # filter(!model %in% c("CU-scenario_high","CU-scenario_mid","CU-scenario_low","CU-nochange")) %>%
  droplevels()

```

```{r inclusion in leaderboard historical}
#filter for historical accuracy table
score_case_historical <- score_case_all %>%
  #filter(!model %in% c("CU-scenario_high","CU-scenario_mid","CU-scenario_low","CU-nochange")) %>%
  group_by(model, score_name) %>% mutate(n_forecasts_wis = sum(score_name == "wis" & !is.na(score_value)),
                                         n_forecasts_mae = sum(score_name == "abs_error" & !is.na(score_value))) %>% ungroup() %>%
  filter(n_forecasts_wis >= (max(n_forecasts_wis)*0.5) | n_forecasts_mae >= (max(n_forecasts_mae)*0.5)) %>% 
  filter(!is.na(score_value)) %>% droplevels()

#filter for historical accuracy table
score_inc_historical <- score_inc_all %>%
  #filter(!model %in% c("CU-scenario_high","CU-scenario_mid","CU-scenario_low","CU-nochange")) %>%
  group_by(model, score_name) %>% mutate(n_forecasts_wis = sum(score_name == "wis" & !is.na(score_value)),
                                         n_forecasts_mae = sum(score_name == "abs_error" & !is.na(score_value))) %>% ungroup() %>%
  filter(n_forecasts_wis >= (max(n_forecasts_wis)*0.5) | n_forecasts_mae >= (max(n_forecasts_mae)*0.5)) %>% 
  filter(!is.na(score_value)) %>% droplevels()
```


```{r inclusion in relative recent calculations}
#Filtered to include only models that have submitted a forecast in recent weeks and the recent forecasts
# score_case_recent <- score_case_10wks  %>%
#   filter(n_weeks_10wksPrior >= max(n_weeks_10wksPrior)*0.5) %>%
#   filter(!is.na(score_value)) %>% ## remove NA scores for comparison to go through
#   droplevels()
# 
# score_inc_recent <- score_inc_10wks %>%
#   filter(n_weeks_10wksPrior >= max(n_weeks_10wksPrior)*0.5) %>%
#   filter(!is.na(score_value)) %>% ## remove NA scores for comparison to go through
#   droplevels()
```


```{r truth data plot}
#function to Plot truth data 
plot_truth <- function(dat) {
ggplot(data = dat, aes(x = target_end_date, y = value)) +
  #geom_line(color = "black") +
  geom_point() +
  geom_line(color = "black") +
  scale_x_date(name = NULL, date_breaks="1 month", date_labels = "%b %d") +
  ylab("incident cases") +
  labs(title = paste("Weekly reported COVID-19 data: \n Models evaluated from", first_eval_sat, "to", last_eval_sat, sep = " "),
                          caption="source: JHU CSSE (observed data)")+
  theme(legend.position = c(.05,.95), legend.justification = c(0,1)) +
  #geom_vline(aes(xintercept= c(first_submission_date -3.5), color = "Submission Date Boundaries"), linetype=2) +
  #geom_vline(aes(xintercept= c(last_submission_date + 3.5), color = "Submission Date Boundaries"), linetype=2) +  
  geom_vline(aes(xintercept= c(first_eval_sat -3.5), color = "Evaluated Date Boundaries"), linetype=2) +
  geom_vline(aes(xintercept= c(last_eval_sat + 3.5), color = "Evaluated Date Boundaries"), linetype=2) +    
  scale_color_manual(name = "", values = c("Evaluated Date Boundaries" = "blue"))# , "Submission Date Boundaries" = "red"))
}
```

```{r location heatmap plot}
#function to plot number of locations

plot_location <- function(x){
  ggplot(x, aes(y=model, x= submission_sat, fill=n_location)) +
    geom_tile() +
    geom_text(aes(label=n_location), size = 7) +
  scale_fill_steps(low="white", high="blue", name = "Number of Locations") +
   xlab("Submission Saturday") + ylab(NULL) +
  scale_x_date(date_labels = "%Y-%m-%d", breaks = c(x$submission_sat)) +
   theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 20),
         axis.title.x = element_text(size = 30),
         axis.text.y = element_text(size = 25),
         title = element_text(size = 20)) +
    guides(fill=FALSE)
}
```

```{r calibration table function}
calib_table <- function(x){
  
 historical_calib <-  x  %>% 
  filter(score_name %in% c("coverage_50","coverage_95")) %>%
  pivot_wider(names_from = score_name, values_from = score_value) %>%
  group_by(model) %>%
  summarise(n_forecasts_historical = n(),
            mean_PI50 = round(sum(coverage_50, na.rm = TRUE) / n(),2),
            mean_PI95 = round(sum(coverage_95, na.rm = TRUE) / n(),2)) %>% ungroup() 
  
  
 recent_calib  <- x  %>%
    filter(score_name %in% c("coverage_50","coverage_95")) %>%
    filter(target_end_date >= first_eval_sat) %>%  droplevels() %>%
  pivot_wider(names_from = score_name, values_from = score_value) %>%
  group_by(model) %>%
   summarise(n_forecasts_recent = n(),
            mean_PI50_recent = round(sum(coverage_50, na.rm = TRUE) / n(),2),
            mean_PI95_recent = round(sum(coverage_95, na.rm = TRUE) / n(),2)) %>%
  ungroup() 
 
 merge(historical_calib, recent_calib, by = "model")
}
```

```{r coverage table}
coverage_function <- function(x) {
  calibration_table <-  x  %>%
  select(model, n_forecasts_recent, mean_PI50_recent, mean_PI95_recent, n_forecasts_historical, mean_PI50, mean_PI95) %>%
  arrange(-mean_PI50_recent)

render <- JS(
  "function(data, type, row) {",
  "  if(type === 'sort' && data === null) {",
  "    return 999999;",
  "  }",
  "  return data;",
  "}"
)


print(datatable(calibration_table, rownames= FALSE, colnames = c("Model", "n recent forecasts", "Recent 50% coverage", "Recent 95% coverage","n historical forecasts" , "Historical 50% coverage", "Historical 95% coverage"), 
              options =  list(pageLength = 5, 
                             autoWidth = TRUE,
                             columnDefs = list(list(width = '200px', targets = "_all", render = render)), 
                             ordering = TRUE),
              filter = c("top")))
  
}
```



```{r plot by location wis}
# select relevant columns:

plot_by_location_wis <- function(df, order) {
scores <- df %>%
  filter(horizon %in% c(1:4)) %>%
  filter(score_name == "wis") %>%
  filter(n_horizons == max(n_horizons),
         n_weeks >= max(n_weeks)*0.5) %>%
  rename(wis = score_value) %>%
  left_join(hub_locations %>% select(location = fips, abbreviation, location_name)) 


# the included models and locations:
models <- unique(scores$model)
locations <- unique(scores$location)
location_names <- unique(scores$location_name)

# function for pairwise comparison of models
pairwise_comparison_location <- function(scores, mx, my, subset = rep(TRUE, nrow(scores)),
                                permutation_test = FALSE){
  
  ############## This line had been deleted, but needs to be included ##########################
  # apply subset:
  scores <- scores[subset, ]
  
  # subsets of available scores for both models:
  subx <- subset(scores, model == mx)
  suby <- subset(scores, model == my)
  
  # merge together and restrict to overlap:
  sub <- merge(subx, suby, by = c("forecast_date", "location", "horizon"),
               all.x = FALSE, all.y = FALSE)
  
  # compute ratio:
  ratio <- sum(sub$wis.x) / sum(sub$wis.y)
  
  # perform permutation tests:
  if(permutation_test){
    pval <- permutationTest(sub$wis.x, sub$wis.y,
                            nPermutation = 999)$pVal.permut
    
    # aggregate by forecast date:
    sub_fcd <- aggregate(cbind(wis.x, wis.y) ~ forecast_date, data = sub, FUN = mean) 
    pval_fcd <- permutationTest(sub_fcd$wis.x, sub_fcd$wis.y,
                                nPermutation = 999)$pVal.permut
  }else{
    pval <- NULL
    pval_fcd <- NULL
  }
  
  return(list(ratio = ratio, pval = pval, pval_fcd = pval_fcd, mx = mx, my = my))
}



# compute pairwise and relative WIS for each location separately:
for(i in seq_along(locations)){
  
  # select location:
  loc <- locations[i]
  loc_name <- location_names[i]
  
  # matrix to store:
  results_ratio_temp <- matrix(ncol = length(models),
                          nrow = length(models),
                          dimnames = list(models, models)) 
  
  # run pairwise comparison for chosen location:
  for(mx in seq_along(models)){
    for(my in 1:mx){
      pwc <- pairwise_comparison_location(scores = scores, mx = models[mx], my = models[my],
                                 permutation_test = FALSE, # disable permutation test to speed up things
                                 subset = scores$location == loc) # this will subset to the respective location inside the function
      results_ratio_temp[mx, my] <- pwc$ratio
      results_ratio_temp[my, mx] <- 1/pwc$ratio
    }
  }
  
  # compute the geometric means etc
  ind_baseline <- which(rownames(results_ratio_temp) == "COVIDhub-baseline")
  geom_mean_ratios_temp <- exp(rowMeans(log(results_ratio_temp[, -ind_baseline]), na.rm = TRUE))
  ratios_baseline_temp <- results_ratio_temp[, "COVIDhub-baseline"]
  ratios_baseline2_temp <- geom_mean_ratios_temp/geom_mean_ratios_temp["COVIDhub-baseline"]
  
  # summarize results:
  to_add <- data.frame(model = names(ratios_baseline2_temp),
                       location = loc,
                       location_name = loc_name,
                       relative_wis = ratios_baseline2_temp,
                       log_relative_wis = log(ratios_baseline2_temp))
  
  # append to already stored:
  if(i == 1){ # initialize at first location
    average_by_loc <- to_add
  }else{
    average_by_loc <- rbind(average_by_loc, to_add)
  }
  
 # cat("Finished", loc_name, "\n")
}


average_by_loc_to_plot <- average_by_loc %>%
  filter(location_name != "American Samoa" & location_name != "Northern Mariana Islands") %>%
  mutate(relative_wis_text = sprintf("%.1f", round(relative_wis, 1)),
         log_relative_wis = log2(relative_wis)) %>%
  filter(!is.na(relative_wis)) %>%
  mutate(model = fct_relevel(model, order))


# plot:
ggplot(average_by_loc_to_plot, 
  aes(x=model, y=location_name, 
    fill= scales::oob_squish(log_relative_wis, range = c(- 2.584963, 2.584963)))) +
  geom_tile() +
  geom_text(aes(label = relative_wis_text), size = 2.5) + # I adapted the rounding
  scale_fill_gradient2(low = "steelblue", high = "red", midpoint = 0, na.value = "grey50", 
                       name = "Relative WIS", 
                       breaks = c(-2,-1,0,1,2), 
                       labels =c("0.25", 0.5, 1, 2, 4)) + 
  xlab(NULL) + ylab(NULL) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
      axis.title.x = element_text(size = 9),
      axis.text.y = element_text(size = 9),
      title = element_text(size = 9)) 
}
```


```{r plot by location mae}
# select relevant columns:

plot_by_location_mae <- function(df) {
  
scores <-  df %>%
  filter(horizon %in% c(1:4)) %>%
  filter(score_name == "abs_error") %>%
  filter(n_horizons == max(n_horizons),
         n_weeks >= max(n_weeks)*0.5 | n_weeks_3wksPrior >= 2 ) %>%
  rename(abs_error = score_value) %>%
  left_join(hub_locations %>% select(location = fips, abbreviation, location_name))


# the included models and locations:
models <- unique(scores$model)
locations <- unique(scores$location)
location_names <- unique(scores$location_name)

# function for pairwise comparison of models
pairwise_comparison_location_mae <- function(scores, mx, my, subset = rep(TRUE, nrow(scores)),
                                permutation_test = FALSE){
  
  ############## This line had been deleted, but needs to be included ##########################
  # apply subset:
  scores <- scores[subset, ]
  
  # subsets of available scores for both models:
  subx <- subset(scores, model == mx)
  suby <- subset(scores, model == my)
  
  # merge together and restrict to overlap:
  sub <- merge(subx, suby, by = c("forecast_date", "location", "horizon"),
               all.x = FALSE, all.y = FALSE)
  
  # compute ratio:
  ratio <- sum(sub$abs_error.x) / sum(sub$abs_error.y)
  
  # perform permutation tests:
  if(permutation_test){
    pval <- permutationTest(sub$abs_error.x, sub$abs_error.y,
                            nPermutation = 999)$pVal.permut
    
    # aggregate by forecast date:
    sub_fcd <- aggregate(cbind(abs_error.x, abs_error.y) ~ forecast_date, data = sub, FUN = mean) 
    pval_fcd <- permutationTest(sub_fcd$abs_error.x, sub_fcd$abs_error.y,
                                nPermutation = 999)$pVal.permut
  }else{
    pval <- NULL
    pval_fcd <- NULL
  }
  
  return(list(ratio = ratio, pval = pval, pval_fcd = pval_fcd, mx = mx, my = my))
}


# compute pairwise and relative abs error for each location separately:
for(i in seq_along(locations)){
  
  # select location:
  loc <- locations[i]
  loc_name <- location_names[i]
  
  # matrix to store:
  results_ratio_temp <- matrix(ncol = length(models),
                          nrow = length(models),
                          dimnames = list(models, models)) 
  
  # run pairwise comparison for chosen location:
  for(mx in seq_along(models)){
    for(my in 1:mx){
      pwc <- pairwise_comparison_location_mae(scores = scores, mx = models[mx], my = models[my],
                                 permutation_test = FALSE, # disable permutation test to speed up things
                                 subset = scores$location == loc) # this will subset to the respective location inside the function
      results_ratio_temp[mx, my] <- pwc$ratio
      results_ratio_temp[my, mx] <- 1/pwc$ratio
    }
  }
  
  # compute the geometric means etc
  ind_baseline <- which(rownames(results_ratio_temp) == "COVIDhub-baseline")
  geom_mean_ratios_temp <- exp(rowMeans(log(results_ratio_temp[, -ind_baseline]), na.rm = TRUE))
  ratios_baseline_temp <- results_ratio_temp[, "COVIDhub-baseline"]
  ratios_baseline2_temp <- geom_mean_ratios_temp/geom_mean_ratios_temp["COVIDhub-baseline"]
  
  # summarize results:
  to_add <- data.frame(model = names(ratios_baseline2_temp),
                       location = loc,
                       location_name = loc_name,
                       relative_mae = ratios_baseline2_temp,
                       log_relative_mae = log(ratios_baseline2_temp))
  
  # append to already stored:
  if(i == 1){ # initialize at first location
    average_by_loc <- to_add
  }else{
    average_by_loc <- rbind(average_by_loc, to_add)
  }
  
  #cat("Finished", loc_name, "\n")
}


average_by_loc_to_plot <- average_by_loc %>%
  filter(location_name != "American Samoa" & location_name != "Northern Mariana Islands") %>%
  mutate(relative_mae_text = sprintf("%.1f", round(relative_mae, 1)),
         log_relative_mae = log2(relative_mae)) %>%
  filter(!is.na(relative_mae)) 

average_by_loc_to_plot$model <- reorder(average_by_loc_to_plot$model, -average_by_loc_to_plot$log_relative_mae)

# plot:
avg_by_loc <- ggplot(average_by_loc_to_plot, 
  aes(x=model, y=location_name, 
    fill= scales::oob_squish(log_relative_mae, range = c(- 2.584963, 2.584963)))) +
  geom_tile() +
  geom_text(aes(label = relative_mae_text), size = 2.5) + # I adapted the rounding
  scale_fill_gradient2(low = "steelblue", high = "red", midpoint = 0, na.value = "grey50", 
                       name = "Relative MAE", 
                       breaks = c(-2,-1,0,1,2), 
                       labels =c("0.25", 0.5, 1, 2, 4)) + 
  xlab(NULL) + ylab(NULL) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
      axis.title.x = element_text(size = 9),
      axis.text.y = element_text(size = 9),
      title = element_text(size = 9)) 

print(avg_by_loc)
}
```


```{r}
wis_plot_function <- function(x,y,order) {
wis_plot <- x %>% 
  filter(target_end_date >= first_eval_sat) %>%
  filter(score_name %in% c("sharpness","overprediction", "underprediction")) %>% 
  group_by(model, score_name) %>% 
  summarise(mean_values = mean(score_value,na.rm = T)) %>% 
  mutate(n_forecasts = n()) %>%
  ungroup() %>%
  #filter(n_forecasts >= (max(n_forecasts)*0.5)) %>% 
  droplevels()  %>%
  filter(model %in% y$model)
   

wis_plot <- wis_plot %>%
  mutate(model = fct_relevel(model, order))


ggplot(wis_plot, aes(fill=score_name, y=mean_values, x=model)) + 
    geom_bar(position="stack", stat="identity", width = .75) +
   theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
         legend.title = element_blank(),
         axis.title.x =  element_blank()) +
  labs(y = "WIS components")
}
```


# Overview
This report provides an evaluation of the accuracy and precision of probabilistic forecasts of COVID-19 cases and deaths submitted to the [US COVID-19 Forecast Hub](https://covid19forecasthub.org/). Some analyses include forecasts submitted starting in April 2020. Others focus on evaluating "recent" forecasts, submitted only in the last `r n_weeks_eval` weeks. 

<!-- The forecasts evaluated were submitted during the time period from `r format(first_submission_date, "%B %d, %Y")` through `r format(last_submission_date, "%B %d, %Y")`. The revision dates of this data was calculated as of `r today()`.
In this weekly report we are evaluating forecasts made in 57 different locations (US on a national level, 50 states, and 6 territories), for 4 horizons over `r n_weeks_eval` submission weeks. We are evaluating incident cases, and incident deaths. 

Additionally, we have included a historical score report to aggregate scores from forecasts that have been submitted to the forecast hub since the first week in April.
-->

In collaboration with the US Centers for Disease Control and Prevention (CDC), the COVID-19 Forecast hub collects short-term COVID-19 forecasts from dozens of research groups around the globe. Every Tuesday morning we combine the most recent forecasts from each team into a single "ensemble" forecast for each of the target submissions. This forecast is used as the official ensemble forecast of the CDC, typically appearing on their [forecasting website](https://www.cdc.gov/coronavirus/2019-ncov/covid-data/mathematical-modeling.html) on Wednesday.

# Incident Case Forecasts {.tabset .tabset-fade}

## Summary Tables {.tabset .tabset-fade}


The first table evaluates models based on their [adjusted relative weighted interval scores (WIS, a measure of distributional accuracy)](https://arxiv.org/abs/2005.12881), and adjusted relative mean absolute error (MAE). Scores are aggregated separately for the most recent 10 weeks and for all historical weeks. To account for the variation in difficult of forecasting different weeks and locations, a pairwise approach was used to calculated the relative adjusted WIS and MAE. Models with relative scores lower than 1 have been more accurate than the baseline on average, whereas relative scores greater than 1 indicate less accuracy than baseline on average.  


The second table evaluates models based on their prediction interval coverage at the 50% and 95% levels. Scores are aggregated seperately for the most recent 10 weeks and for all historical weeks. 

<!-- * The **prediction interval coverage**  measures  the proportion of times a prediction interval of a certain level covered the true value, to assess the degree to which forecasts accurately characterized uncertainty about future observations. Well calibrated models should have a 50% coverage level of 0.5 and a 95% coverage level of 0.95. 

* The **weighted interval score (WIS)** is a proper score that combines a set of interval scores for probabilistic forecasts that provide quantiles of the predictive forecast distribution. To account for the variation in difficult of forecasting different weeks and locations, a pairwis approach was used to calculated the relative adjusted WIS. The code for this comparison can be found [here](https://github.com/jbracher/pairwise_comparisons). A preprint on this method for calculating the WIS can be found [here](https://arxiv.org/pdf/2005.12881.pdf). Models with an adjusted relative WIS  lower than 1 are more accurate than the baseline, and models with an adjusted relative WIS greater than 1 are less accurate than the baseline is predicting the number of incident cases. 

* The **mean absolute error** is defined as the the difference between the forecasted value and the actual value. For this calculation, point forecasts submitted by teams were used. When point forecasts were not available, the 0.50 quantile was used. Similar to calculating the WIS, a pairwise approach was used to account for variation across locations and weeks. Models with an adjusted relative MAE lower than 1 are more accurate than the baseline, and models with an adjusted relative MAE greater than 1 are less accurate than the baseline is predicting the number of incident cases. 
-->
 
Inclusion criteria for each column are detailed below the table. 



### Accuracy Table 

```{r}
#calibration table 
case_calibration <- calib_table(score_case_leaderboard)
```

```{r relative wis case}
#Calculate pairwise WIS
# # helper function
# next_monday <- function(date){
#   nm <- rep(NA, length(date))
#   for(i in seq_along(date)){
#     nm[i] <- date[i] + (0:6)[weekdays(date[i] + (0:6)) == "Monday"]
#   }
#   return(as.Date(nm, origin = "1970-01-01"))
# }

inc_scores <- score_case_10wks %>%
  filter(!is.na(score_value)) %>%
  filter(n_locations >= 25) %>% 
  droplevels()

# bring all timezeros to Monday:
inc_scores$timezero <- inc_scores$submission_sat

# restrict to 1-4 wk ahead state-level 
scores <- inc_scores %>% filter(horizon %in% paste(1:4),  location %in% US_fips) %>%
  filter(score_name %in% c("abs_error", "wis")) %>%
  select("model", "timezero", "location", "horizon", "score_name", "score_value") %>%
  pivot_wider(names_from = score_name, values_from = score_value) %>% 
  filter(!is.na(wis)) %>%
  droplevels()

# the included models:
models <- unique(scores$model)

pairwise_comparison <- function(scores, mx, my, subset = rep(TRUE, nrow(scores)),
                                permutation_test = FALSE){
  # subsets of available scores for both models:
  subx <- subset(scores, model == mx)
  suby <- subset(scores, model == my)
  # merge together and restrict to overlap:
  sub <- merge(subx, suby, by = c("timezero", "location", "horizon"),
               all.x = FALSE, all.y = FALSE)
  ##### catch common problems:
  ##### no overlap between targets covered by x and y:
  if(nrow(sub) == 0){
    warning("No overlap of covered forecast targets for ", mx, "and", my, ". Returning NA.")
    return(list(ratio = NA, pval = NA, pval_fcd = NA, mx = mx, my = my))
  }
  ##### unavailable scores (likely because a model issues only point forecasts?)
  if(any(is.na(subx$wis))){
    warning("Some or all wis values are NA for ", mx, ". Returning NA.")
    return(list(ratio = NA, pval = NA, pval_fcd = NA, mx = mx, my = my))
  }
  if(any(is.na(suby$wis))){
    warning("Some or all wis values are NA for ", my, ". Returning NA.")
    return(list(ratio = NA, pval = NA, pval_fcd = NA, mx = mx, my = my))
  }

  # compute ratio:
  
  # matrices to store:
  results_ratio <- results_pval <- results_pval_fcd <- matrix(ncol = length(models),
                                                              nrow = length(models),
                                                              dimnames = list(models, models))

  ratio <- sum(sub$wis.x) / sum(sub$wis.y)
  # perform permutation tests:
  if(permutation_test){
    pval <- permutationTest(sub$wis.x, sub$wis.y,
                            nPermutation = 999)$pVal.permut
    ##### aggregate by forecast date:
    sub_fcd <- aggregate(cbind(wis.x, wis.y) ~ timezero, data = sub, FUN = mean)
    # catch error if too many observations
    if(nrow(sub_fcd) > 5){
      pval_fcd <- permutationTest(sub_fcd$wis.x, sub_fcd$wis.y,
                                  nPermutation = 999)$pVal.permut
    }else{
      warning("Too few observations to compute p-value for ", mx, " and ", my, " with aggregation by forecast date. Returning NA.")
      pval_fcd <- NA
    }
  }else{
    pval <- NULL
    pval_fcd <- NULL
  }
  return(list(ratio = ratio, pval = pval, pval_fcd = pval_fcd, mx = mx, my = my))
}

# matrices to store:
results_ratio <- results_pval <- results_pval_fcd <- matrix(ncol = length(models),
                                                            nrow = length(models),
                                                            dimnames = list(models, models))

set.seed(123) # set seed for permutation tests

for(mx in seq_along(models)){
  for(my in 1:mx){
    pwc <- pairwise_comparison(scores = scores, mx = models[mx], my = models[my],
                               permutation_test = FALSE)

    results_ratio[mx, my] <- pwc$ratio
    results_ratio[my, mx] <- 1/pwc$ratio
    ## commenting these out b/c no permutation test being run
    #results_pval[mx, my] <-
    #  results_pval[my, mx] <- pwc$pval
    #results_pval_fcd[mx, my] <-
    #  results_pval_fcd[my, mx] <- pwc$pval_fcd
  }
}

ind_baseline <- which(rownames(results_ratio) == "COVIDhub-baseline")
geom_mean_ratios <- exp(rowMeans(log(results_ratio[, -ind_baseline]), na.rm = TRUE))
ratios_baseline <- results_ratio[, "COVIDhub-baseline"]
ratios_baseline2 <- geom_mean_ratios/geom_mean_ratios["COVIDhub-baseline"]

tab <- data.frame(model = names(geom_mean_ratios),
                  geom_mean_ratios = geom_mean_ratios,
                  ratios_baseline = ratios_baseline,
                  ratios_baseline2 = ratios_baseline2)

tab <- tab[order(tab$ratios_baseline2), ]


pairwise_scores <- tab %>%
  mutate(relative_wis = round(ratios_baseline2, 2)) %>%
  select(model, relative_wis) 
```


```{r relative mae case }
scores <- inc_scores %>% filter(horizon %in% paste(1:4),  location %in% US_fips) %>%
  select("model", "timezero", "location", "horizon", "score_name", "score_value") %>%
  filter(score_name %in% c("abs_error", "wis")) %>%
  pivot_wider(names_from = score_name, values_from = score_value) %>% 
  filter(!is.na(abs_error)) %>%
  droplevels()

# the included models:
models <- unique(scores$model)

pairabs_error_comparison <- function(scores, mx, my, subset = rep(TRUE, nrow(scores)),
                                permutation_test = FALSE){
  # subsets of available scores for both models:
  subx <- subset(scores, model == mx)
  suby <- subset(scores, model == my)
  # merge together and restrict to overlap:
  sub <- merge(subx, suby, by = c("timezero", "location", "horizon"),
               all.x = FALSE, all.y = FALSE)
  ##### catch common problems:
  ##### no overlap between targets covered by x and y:
  if(nrow(sub) == 0){
    warning("No overlap of covered forecast targets for ", mx, "and", my, ". Returning NA.")
    return(list(ratio = NA, pval = NA, pval_fcd = NA, mx = mx, my = my))
  }
  ##### unavailable scores (likely because a model issues only point forecasts?)
  if(any(is.na(subx$abs_error))){
    warning("Some or all abs_error values are NA for ", mx, ". Returning NA.")
    return(list(ratio = NA, pval = NA, pval_fcd = NA, mx = mx, my = my))
  }
  if(any(is.na(suby$abs_error))){
    warning("Some or all abs_error values are NA for ", my, ". Returning NA.")
    return(list(ratio = NA, pval = NA, pval_fcd = NA, mx = mx, my = my))
  }
  # compute ratio:
  
  # matrices to store:
  results_ratio <- results_pval <- results_pval_fcd <- matrix(ncol = length(models),
                                                            nrow = length(models),
                                                            dimnames = list(models, models))

  ratio <- sum(sub$abs_error.x) / sum(sub$abs_error.y)
  # perform permutation tests:
  if(permutation_test){
    pval <- permutationTest(sub$abs_error.x, sub$abs_error.y,
                            nPermutation = 999)$pVal.permut
    ##### aggregate by forecast date:
    sub_fcd <- aggregate(cbind(abs_error.x, abs_error.y) ~ timezero, data = sub, FUN = mean)
    # catch error if too many observations
    if(nrow(sub_fcd) > 5){
      pval_fcd <- permutationTest(sub_fcd$abs_error.x, sub_fcd$abs_error.y,
                                  nPermutation = 999)$pVal.permut
    }else{
      warning("Too few observations to compute p-value for ", mx, " and ", my, " with aggregation by forecast date. Returning NA.")
      pval_fcd <- NA
    }
  }else{
    pval <- NULL
    pval_fcd <- NULL
  }
  return(list(ratio = ratio, pval = pval, pval_fcd = pval_fcd, mx = mx, my = my))
}

# matrices to store:
results_ratio <- results_pval <- results_pval_fcd <- matrix(ncol = length(models),
                                                            nrow = length(models),
                                                            dimnames = list(models, models))
set.seed(123) # set seed for permutation tests

for(mx in seq_along(models)){
  for(my in 1:mx){
    pwc <- pairabs_error_comparison(scores = scores, mx = models[mx], my = models[my],
                               permutation_test = FALSE)

    results_ratio[mx, my] <- pwc$ratio
    results_ratio[my, mx] <- 1/pwc$ratio
    ## commenting these out b/c no permutation test being run
    #results_pval[mx, my] <-
    #  results_pval[my, mx] <- pwc$pval
    #results_pval_fcd[mx, my] <-
    #  results_pval_fcd[my, mx] <- pwc$pval_fcd
  }
}

ind_baseline <- which(rownames(results_ratio) == "COVIDhub-baseline")
geom_mean_ratios <- exp(rowMeans(log(results_ratio[, -ind_baseline]), na.rm = TRUE))
ratios_baseline <- results_ratio[, "COVIDhub-baseline"]
ratios_baseline2 <- geom_mean_ratios/geom_mean_ratios["COVIDhub-baseline"]

tab <- data.frame(model = names(geom_mean_ratios),
                  geom_mean_ratios = geom_mean_ratios,
                  ratios_baseline = ratios_baseline,
                  ratios_baseline2 = ratios_baseline2)

tab <- tab[order(tab$ratios_baseline2), ]

pairwise_scores_mae <- tab %>%
  mutate(relative_mae = round(ratios_baseline2, 2)) %>%
  select(model, relative_mae) 
```


```{r permutation test for historical data}
inc_scores <- score_case_historical %>%
  filter(n_locations >= 25) %>%
  filter(n_weeks >= 4) %>%
  droplevels()

# bring all timezeros to Monday:
inc_scores$timezero <- inc_scores$submission_sat

# restrict to 1-4 wk ahead state-level 
scores <- inc_scores %>% filter(horizon %in% paste(1:4),  location %in% US_fips) %>%
  filter(!is.na(score_value)) %>%
  select("model", "timezero", "location", "horizon", "score_name", "score_value") %>%
  filter(score_name %in% c("abs_error", "wis")) %>%
  pivot_wider(names_from = score_name, values_from = score_value) %>% filter(!is.na(wis))

# the included models:
models <- unique(scores$model)


# matrices to store:
results_ratio <- results_pval <- results_pval_fcd <- matrix(ncol = length(models),
                                                            nrow = length(models),
                                                            dimnames = list(models, models))

set.seed(123) # set seed for permutation tests

for(mx in seq_along(models)){
  for(my in 1:mx){
    pwc <- pairwise_comparison(scores = scores, mx = models[mx], my = models[my],
                               permutation_test = FALSE)

    results_ratio[mx, my] <- pwc$ratio
    results_ratio[my, mx] <- 1/pwc$ratio
    ## commenting these out b/c no permutation test being run
    # results_pval[mx, my] <-
    #   results_pval[my, mx] <- pwc$pval
    # results_pval_fcd[mx, my] <-
    #   results_pval_fcd[my, mx] <- pwc$pval_fcd
  }
}

ind_baseline <- which(rownames(results_ratio) == "COVIDhub-baseline")
geom_mean_ratios <- exp(rowMeans(log(results_ratio[, -ind_baseline]), na.rm = TRUE))
ratios_baseline <- results_ratio[, "COVIDhub-baseline"]
ratios_baseline2 <- geom_mean_ratios/geom_mean_ratios["COVIDhub-baseline"]

tab <- data.frame(model = names(geom_mean_ratios),
                  geom_mean_ratios = geom_mean_ratios,
                  ratios_baseline = ratios_baseline,
                  ratios_baseline2 = ratios_baseline2)

tab <- tab[order(tab$ratios_baseline2), ]

historical_wis <- tab %>%
  mutate(relative_wis_historical = round(ratios_baseline2, 2)) %>%
  select(model, relative_wis_historical) 
```

```{r}
scores <- inc_scores %>% filter(horizon %in% paste(1:4),  location %in% US_fips) %>%
  select("model", "timezero", "location", "horizon", "score_name", "score_value") %>%
  filter(score_name %in% c("abs_error", "wis")) %>%
  pivot_wider(names_from = score_name, values_from = score_value) %>% 
  filter(!is.na(abs_error)) %>%
  droplevels()

# the included models:
models <- unique(scores$model)


# matrices to store:
results_ratio <- results_pval <- results_pval_fcd <- matrix(ncol = length(models),
                                                            nrow = length(models),
                                                            dimnames = list(models, models))

set.seed(123) # set seed for permutation tests

for(mx in seq_along(models)){
  for(my in 1:mx){
    pwc <- pairabs_error_comparison(scores = scores, mx = models[mx], my = models[my],
                               permutation_test = FALSE)

    results_ratio[mx, my] <- pwc$ratio
    results_ratio[my, mx] <- 1/pwc$ratio
    ## commenting these out b/c no permutation test being run
    # results_pval[mx, my] <-
    #   results_pval[my, mx] <- pwc$pval
    # results_pval_fcd[mx, my] <-
    #   results_pval_fcd[my, mx] <- pwc$pval_fcd
  }
}

ind_baseline <- which(rownames(results_ratio) == "COVIDhub-baseline")
geom_mean_ratios <- exp(rowMeans(log(results_ratio[, -ind_baseline]), na.rm = TRUE))
ratios_baseline <- results_ratio[, "COVIDhub-baseline"]
ratios_baseline2 <- geom_mean_ratios/geom_mean_ratios["COVIDhub-baseline"]

tab <- data.frame(model = names(geom_mean_ratios),
                  geom_mean_ratios = geom_mean_ratios,
                  ratios_baseline = ratios_baseline,
                  ratios_baseline2 = ratios_baseline2)

tab <- tab[order(tab$ratios_baseline2), ]


historical_mae <- tab %>%
  mutate(historical_relative_mae = round(ratios_baseline2, 2)) %>%
  select(model, historical_relative_mae) 
```

```{r}
leaderboard_table <- case_calibration %>%
  full_join(pairwise_scores) %>%
  full_join(historical_wis) %>%
  full_join(pairwise_scores_mae) %>%
  full_join(historical_mae) %>%
  select(model, n_forecasts_recent, relative_wis, relative_mae,  n_forecasts_historical, relative_wis_historical, historical_relative_mae) %>%
  arrange(relative_wis) %>% 
  filter(!is.na(relative_wis) | !is.na(relative_mae) | !is.na(relative_wis_historical) | !is.na(historical_relative_mae))

render <- JS(
  "function(data, type, row) {",
  "  if(type === 'sort' && data === null) {",
  "    return 999999;",
  "  }",
  "  return data;",
  "}"
)


datatable(leaderboard_table, rownames= FALSE, colnames = c("Model", "n recent forecasts",  "Recent rel WIS",  "Recent rel MAE", "n historical forecasts" , "Historical rel WIS", "Historical rel MAE"), 
              options =  list(pageLength = 5, 
                             autoWidth = TRUE,
                             columnDefs = list(list(width = '300px', targets = "_all", render = render)), 
                             ordering = TRUE),
              filter = c("top"))
```


```{r}
case_model_order <- leaderboard_table %>%
  arrange(-relative_wis) %>% pull(model)
```

To calculate each column in our table, different inclusion criteria were applied. This table only includes models that have submitted forecasts for at least 50% of forecasts for the last 10 weeks or at least 50% of forecasts since the first week in April. 

* The column titled, "n recent forecasts" lists the number of forecasts a team has submitted with a target end date over the most recent `r n_weeks_eval` week period.

* Columns 3 and 4 calculate the adjusted relative WIS over the most recent `r n_weeks_eval` week period and the adjusted relative MAE over the most recent `r n_weeks_eval` week period. For inclusion in these rows, a model must have forecasts for at least 50% of the evaluated forecasts in the most recent evaluation period. 

* Column 5 shows the number of historical models a team has submitted. 

* Columns 6 and 7 show the adjusted WIS and adjusted MAE over a historical period beginning the first week in March. For inclusion in this figure, a model must have submitted predictions for 50% or more of the evaluated forecasts in the historical evaluation period.



### Coverage Table 

```{r}
(coverage_table  <- coverage_function(case_calibration))
```


For inclusion in this table, a model most have contributed forecasts for 5 or more weeks total since the beginning of April, or have submitted forecasts during at least 2 out of the last 3 evaluated weeks. This inclusion criteria was applied in order to score models that submitted for a substantial amount of weeks at any point during the pandemic but may no longer be submitting, but also to evaluate new teams that have recently joined our forecasting efforts. 



<!-- ## Number of Locations -->

<!-- ```{r filters for analysis inc case, fig.width=8, fig.height=10} -->
<!-- #counts of case submissions for the week -->

<!-- #Count of models that have submitted for last 10 evaluated weeks -->
<!-- n_unique_models_case <- score_case_10wks  %>% -->
<!--   pull(model) %>% unique() -->

<!--  <- score_case_10wks  %>% -->
<!--   filter(n_weeks_10wksPrior == max(n_weeks_10wksPrior)) %>% -->
<!--   pull(model) %>% unique() %>% length() -->

<!-- n_models_all_locations <- score_case_10wks  %>% -->
<!--   filter(n_locations >= 50) %>% -->
<!--   pull(model) %>% unique() %>% length() -->

<!-- <- score_case_10wks  %>% -->
<!--   group_by(horizon) %>% -->
<!--   filter(n_horizons == max(n_horizons)) %>% -->
<!--   pull(model) %>% unique() %>% length() -->
<!-- ``` -->


<!-- This figure shows the number of locations each model submitted a weekly incidence case forecast for the last 10 evaluated weeks. The maximum number of locations is 57, which includes all 50 states, a National level forecast, and 6 US territories. -->

<!-- The dates listed on the x-axis are the Saturday before the first horizon. This is the Saturday associated with the target submission week. If a model is submitted on Tuesday - Friday, the Saturday listed occurs after the submission. If the model is submitted on a Sunday or Monday, the Saturday occurs before the submission date. -->

<!--  The number of models that submitted forecasts for all `r n_weeks_eval` weeks was `. -->


<!-- ```{r,fig.width=20, fig.height=20} -->
<!-- for_loc_figure_case <- score_inc_leaderboard   %>% -->
<!--   filter(score_name == "wis") %>% -->
<!--   filter(horizon == "1") %>% -->
<!--   filter(submission_sat >= first_submission_date) %>% -->
<!--   group_by(model, submission_sat) %>% -->
<!--   summarise(n_location = n()) %>% -->
<!--   ungroup() %>% -->
<!--   group_by(model, n_location) %>% -->
<!--   mutate(n_weeks = n()) -->

<!-- for_loc_figure_case$model <- reorder(for_loc_figure_case$model, for_loc_figure_case$n_weeks) -->

<!-- plot_location(for_loc_figure_case) -->
<!-- ``` -->

## WIS components


The data in this graph has been aggregated over all locations and submission weeks. The models included have submitted forecasts for at least 50% of forecasts out of the last 10 weeks. This is the same exclusion criteria applied for WIS scores in the recent evaluation period. 

The sum of the bars adds up to the WIS score. Of note, these values may not be exactly the same as the relative WIS scores shown in the leaderboard table because these are not adjusted for weeks or locations missing. 

```{r wis bar function, fig.height= 8, fig.width=13}
wis_plot_function(x = score_case_all, y = pairwise_scores, order = case_model_order)
```


## Evaluation by Week  {.tabset .tabset-fade}

In the following figures, we have evaluated models across multiple forecasting weeks. Points included in this comparison are for models that have submitted probabilistic forecasts for all 50 states. 

For the first 2 figures, WIS is used as a metric. The first figure shows the mean WIS across all 50 states for submission weeks beginning the first week in April at a 1 week horizon. The second figure shows the mean WIS aggregated across locations, however it is for a 4 week horizon.

**To view a specific team, double click on the team names in the legend. To view a value on the plot, click on the point in the forecast of interest. To view a specific time of interest, highlight that section on the graph or use the zoom functionality. **

### 1 Week Horizon WIS
```{r,fig.width=10, fig.height=6}
by_week_function <- function(df, var) {
  df %>%
  filter(score_name == var) %>%
  filter(location %in% c(US_fips)) %>%
  group_by(model, target_end_date, horizon) %>%
  mutate(n_US_location = n()) %>%
  ungroup() %>%
  filter(n_US_location == max(n_US_location)) %>%
  group_by(model,horizon, target_end_date) %>%
  summarise(mean_score = mean(score_value))
}

plot_byweek_function <- function(df, var, horizon_num) {
  ggplot(data =  df %>% filter(horizon == horizon_num), aes(label = model, 
                                     labelx = target_end_date,
                                     labely = mean_score,
                                     x = target_end_date, 
                                     y = mean_score, color = model)) +
  geom_line(aes(group = model), alpha=.5) +
  geom_point(aes(group = model), alpha=.5, size = 2) +
  expand_limits(y=0) +
  scale_y_continuous(name = paste("Average",var)) +
  guides(color=FALSE, group = FALSE) +
  ggtitle(paste0("Average ", horizon_num,"-week ahead ",var," by model")) +
  xlab("Target End Date") +
  theme(axis.ticks.length.x = unit(0.5, "cm"),
    axis.text.x = element_text(vjust = 7, hjust = -0.2))
}

byweek_case <- by_week_function(score_case_all, var = "wis") %>% ungroup()
by_week_wis_1wk <- plot_byweek_function(byweek_case, var = "wis", horizon_num = "1")
ggplotly(by_week_wis_1wk, tooltip = c("label", "labelx", "labely"))

```

### 4 Week Horizon WIS

In this figure, the dotted black line represents the average 1 week ahead error. There is often larger error for the 4 week horizon compared to the 1 week horizon. 

```{r,fig.width=10, fig.height=6}
#calc 1 week error
meanwis_1wk <- byweek_case %>%
  filter(horizon == "1") %>%
  group_by(target_end_date) %>%
  summarise(mean_score = mean(mean_score, na.rm = TRUE)) %>%
  mutate(model = "`average error for 1 week horizon`",
         horizon = "4") %>%
  select(model, horizon, target_end_date, mean_score)
  

by_week_wis_4wk <- plot_byweek_function(byweek_case, var = "wis", horizon_num = "4") +
   geom_line(data = meanwis_1wk, aes(label = model, x = target_end_date, y = mean_score), alpha=.5, color = "black", linetype = 2) +
  geom_point(data = meanwis_1wk, aes(x = target_end_date, y = mean_score), alpha=.5, size = 2, color = "black") 
ggplotly(by_week_wis_4wk,tooltip = c("label", "labelx", "labely"))
```


### 1 Week Horizon 95% Coverage

We would expect a well calibrated model to have a value of 95% in this plot. 

```{r,fig.width=10, fig.height=6}
byweek_case <- by_week_function(score_case_all, var = "coverage_95")
by_week_wis_1wk <- plot_byweek_function(byweek_case, var = "coverage_95", horizon_num = "1") +
  geom_hline(yintercept = .95)
ggplotly(by_week_wis_1wk,tooltip = c("label", "labelx", "labely"))
```

### 4 Week Horizon 95% Coverage

We would expect a well calibrated model to have a value of 95% in this plot. There is typically larger error for the 4 week horizon compared to the 1 week horizon. 

```{r,fig.width=10, fig.height=6}
by_week_wis_4wk <- plot_byweek_function(byweek_case, var = "coverage_95", horizon_num = "4") +
  geom_hline(yintercept = .95)

ggplotly(by_week_wis_4wk, tooltip = c("label", "labelx", "labely"))
```


<!-- ## Location Specific WIS -->


<!-- ```{r fig.height=10, fig.width= 11} -->

<!-- plot_avg_by_loc <- function(df) { -->

<!--   average_by_loc <- df %>% -->
<!--   filter(horizon %in% c(1:4)) %>% -->
<!--   filter(score_name == "wis") %>% -->
<!--   filter(n_horizons == max(n_horizons), -->
<!--          n_weeks >= max(n_weeks)*0.5 | n_weeks_3wksPrior >= 2 ) %>% -->
<!--   group_by(model, location) %>% -->
<!--   summarise(avg_wis = round(mean(score_value),1)) %>% -->
<!--   group_by(location) %>% -->
<!--   mutate(relative_wis = avg_wis / avg_wis[model == "COVIDhub-baseline"]) %>% -->
<!--   ungroup() %>% -->
<!--   mutate(log_relative_wis = ifelse(relative_wis == 0, 0, log2(relative_wis)), -->
<!--     log_relative_wis = ifelse(log_relative_wis > 3, 3, log_relative_wis)) %>% -->
<!--     filter(!is.na(relative_wis)) %>% -->
<!--   left_join(hub_locations %>% select(location = fips, abbreviation)) -->


<!-- average_by_loc$model<- reorder(average_by_loc$model, -average_by_loc$log_relative_wis) #sort models by WIS for plot -->
<!-- average_by_loc$abbreviation <- reorder(average_by_loc$abbreviation, average_by_loc$avg_wis) -->

<!-- ggplot(average_by_loc, aes(x=model, y=abbreviation ,fill= log_relative_wis)) + -->
<!--   geom_tile() + -->
<!--   geom_text(aes(label=round(avg_wis)), size = 3) + -->
<!--   scale_fill_gradient2(low = "steelblue", high = "red", midpoint = 0, na.value = "grey50", name = "Relative WIS", -->
<!--                        breaks = c(-2,-1,0,1,2), labels =c(0.25, 0.5, 1, 2, 4)) + -->
<!--   xlab("Scored Models") + ylab("Location") + -->
<!--   theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 10), -->
<!--       axis.title.x = element_text(size = 9), -->
<!--       axis.text.y = element_text(size = 9), -->
<!--       title = element_text(size = 9)) -->
<!-- } -->


<!-- plot_avg_by_loc(score_case_10wks) -->
<!-- ``` -->


## Evaluation by location {.tabset .tabset-fade}

This figures below show model performance stratified by location. We have only included included models that have submitted forecasts for all 4 horizons and at least 50% of weeks over the past 10 evaluated weeks. 

The color scheme shows the WIS score relative to the baseline. The only locations evaluated are 50 states and a national level forecast.

<!-- ### Evaluation by WIS -->

```{r, width=16, fig.height=10}
plot_by_location_wis(score_case_10wks, order = case_model_order)
```


<!-- ### Evaluation by MAE -->
<!-- ``````{r, width=15, fig.height=11} -->
<!-- plot_by_location_mae(score_case_10wks) -->
<!-- ``` -->


## Observed data 

This figure shows the number of incident reported COVID-19 cases reported each week in the US. The period between the vertical blue lines shows the weeks included in the "recent" model evaluations. 

```{r, fig.width=8, fig.height=5}
truth_US_case <- truth_dat_case %>%
  filter(location == "US")

plot_truth(dat = truth_US_case)
```



# Incident Death Forecasts {.tabset .tabset-fade}


## Summary Tables {.tabset .tabset-fade}


The first table below evaluates models based on their [adjusted relative weighted interval scores (WIS, a measure of distributional accuracy)](https://arxiv.org/abs/2005.12881), and adjusted relative mean absolute error (MAE). Scores are aggregated separately for the most recent 10 weeks and for all historical weeks. To account for the variation in difficult of forecasting different weeks and locations, a pairwise approach was used to calculated the relative adjusted WIS and MAE. Models with relative scores lower than 1 have been more accurate than the baseline on average, whereas relative scores greater than 1 indicate less accuracy than baseline on average.  


The second table evaluates models based on their prediction interval coverage at the 50% and 95% levels. Scores are aggregated seperately for the most recent 10 weeks and for all historical weeks. 

<!--The table included below evaluated models based on their prediction interval coverage (50% and 95% coverage), and their adjusted relative weighted interval scores (WIS) and adjusted relative mean absolute error (MAE) for a recent and historical number of weeks. 

* The **prediction interval coverage**  measures  the proportion of times a prediction interval of a certain level covered the true value, to assess the degree to which forecasts accurately characterized uncertainty about future observations. Well calibrated models should have a 50% coverage level of 0.5 and a 95% coverage level of 0.95. 

* The **weighted interval score (WIS)** is a proper score that combines a set of interval scores for probabilistic forecasts that provide quantiles of the predictive forecast distribution. To account for the variation in difficult of forecasting different weeks and locations, a pairwis approach was used to calculated the relative adjusted WIS. The code for this comparison can be found [here](https://github.com/jbracher/pairwise_comparisons). A preprint on this method for calculating the WIS can be found [here](https://arxiv.org/pdf/2005.12881.pdf). Models with an adjusted relative WIS  lower than 1 are more accurate than the baseline, and models with an adjusted relative WIS greater than 1 are less accurate than the baseline is predicting the number of incident cases. 

* The **mean absolute error (MAE)** is defined as the the difference between the forecasted value and the actual value. For this calculation, point forecasts submitted by teams were used. When point forecasts were not available, the 0.50 quantile was used. Similar to calculating the WIS, a pairwise approach was used to account for variation across locations and weeks. Models with an adjusted relative MAE lower than 1 are more accurate than the baseline, and models with an adjusted relative MAE greater than 1 are less accurate than the baseline is predicting the number of incident cases. 
-->
 
Inclusion criteria for each column are detailed below the table. 

```{r}
#calibration table 
inc_calibration <- calib_table(score_inc_leaderboard)
```



### Accuracy Table
```{r}
inc_scores <- score_inc_10wks %>%
  filter(n_locations >= 25) %>%
  filter(n_weeks >= 4) %>%
  droplevels()

# bring all timezeros to Monday:
inc_scores$timezero <- inc_scores$submission_sat

# restrict to 1-4 wk ahead state-level 
scores <- inc_scores %>% filter(horizon %in% paste(1:4), location %in% US_fips) %>%
  filter(!is.na(score_value)) %>%
  select("model", "timezero", "location", "horizon", "score_name", "score_value") %>%
  filter(score_name %in% c("abs_error", "wis")) %>%
  pivot_wider(names_from = score_name, values_from = score_value) %>% filter(!is.na(wis))


# the included models:
models <- unique(scores$model)

# matrices to store:
results_ratio <- results_pval <- results_pval_fcd <- matrix(ncol = length(models),
                                                            nrow = length(models),
                                                            dimnames = list(models, models))

set.seed(123) # set seed for permutation tests

for(mx in seq_along(models)){
  for(my in 1:mx){
    pwc <- pairwise_comparison(scores = scores, mx = models[mx], my = models[my],
                               permutation_test = FALSE)

    results_ratio[mx, my] <- pwc$ratio
    results_ratio[my, mx] <- 1/pwc$ratio
    ## commenting these out b/c no permutation test being run
    # results_pval[mx, my] <-
    #   results_pval[my, mx] <- pwc$pval
    # results_pval_fcd[mx, my] <-
    #   results_pval_fcd[my, mx] <- pwc$pval_fcd
  }
}

ind_baseline <- which(rownames(results_ratio) == "COVIDhub-baseline")
geom_mean_ratios <- exp(rowMeans(log(results_ratio[, -ind_baseline]), na.rm = TRUE))
ratios_baseline <- results_ratio[, "COVIDhub-baseline"]
ratios_baseline2 <- geom_mean_ratios/geom_mean_ratios["COVIDhub-baseline"]

tab <- data.frame(model = names(geom_mean_ratios),
                  geom_mean_ratios = geom_mean_ratios,
                  ratios_baseline = ratios_baseline,
                  ratios_baseline2 = ratios_baseline2)

tab <- tab[order(tab$ratios_baseline2), ]

pairwise_scores <- tab %>%
  mutate(relative_wis = round(ratios_baseline2, 2)) %>%
  select(model, relative_wis) 
```

```{r}
scores <- inc_scores %>% filter(horizon %in% paste(1:4),  location %in% US_fips) %>%
  select("model", "timezero", "location", "horizon", "score_name", "score_value") %>%
  filter(score_name %in% c("abs_error", "wis")) %>%
  pivot_wider(names_from = score_name, values_from = score_value) %>% 
  filter(!is.na(abs_error)) %>%
  droplevels()

# the included models:
models <- unique(scores$model)

# matrices to store:
results_ratio <- results_pval <- results_pval_fcd <- matrix(ncol = length(models),
                                                            nrow = length(models),
                                                            dimnames = list(models, models))

set.seed(123) # set seed for permutation tests

for(mx in seq_along(models)){
  for(my in 1:mx){
    pwc <- pairabs_error_comparison(scores = scores, mx = models[mx], my = models[my],
                               permutation_test = FALSE)

    results_ratio[mx, my] <- pwc$ratio
    results_ratio[my, mx] <- 1/pwc$ratio
    # results_pval[mx, my] <-
    #   results_pval[my, mx] <- pwc$pval
    # results_pval_fcd[mx, my] <-
    #   results_pval_fcd[my, mx] <- pwc$pval_fcd
  }
}

ind_baseline <- which(rownames(results_ratio) == "COVIDhub-baseline")
geom_mean_ratios <- exp(rowMeans(log(results_ratio[, -ind_baseline]), na.rm = TRUE))
ratios_baseline <- results_ratio[, "COVIDhub-baseline"]
ratios_baseline2 <- geom_mean_ratios/geom_mean_ratios["COVIDhub-baseline"]

tab <- data.frame(model = names(geom_mean_ratios),
                  geom_mean_ratios = geom_mean_ratios,
                  ratios_baseline = ratios_baseline,
                  ratios_baseline2 = ratios_baseline2)

tab <- tab[order(tab$ratios_baseline2), ]


pairwise_scores_mae <- tab %>%
  mutate(relative_mae = round(ratios_baseline2, 2)) %>%
  select(model, relative_mae) 
```


```{r}
inc_scores <- score_inc_historical %>%
  filter(n_locations >= 25) %>%
  filter(n_weeks >= 4) %>%
  droplevels()

# bring all timezeros to Monday:
inc_scores$timezero <- inc_scores$submission_sat

# restrict to 1-4 wk ahead state-level 
scores <- inc_scores %>% filter(horizon %in% paste(1:4), location %in% US_fips) %>%
  filter(!is.na(score_value)) %>%
  select("model", "timezero", "location", "horizon", "score_name", "score_value") %>%
  filter(score_name %in% c("abs_error", "wis")) %>% 
  pivot_wider(names_from = score_name, values_from = score_value) %>% filter(!is.na(wis))

# the included models:
models <- unique(scores$model)


# matrices to store:
results_ratio <- results_pval <- results_pval_fcd <- matrix(ncol = length(models),
                                                            nrow = length(models),
                                                            dimnames = list(models, models))

set.seed(123) # set seed for permutation tests

for(mx in seq_along(models)){
  for(my in 1:mx){
    pwc <- pairwise_comparison(scores = scores, mx = models[mx], my = models[my],
                               permutation_test = FALSE)

    results_ratio[mx, my] <- pwc$ratio
    results_ratio[my, mx] <- 1/pwc$ratio
    ## commenting these out b/c no permutation test being run
    # results_pval[mx, my] <-
    #   results_pval[my, mx] <- pwc$pval
    # results_pval_fcd[mx, my] <-
    #   results_pval_fcd[my, mx] <- pwc$pval_fcd
  }
}

ind_baseline <- which(rownames(results_ratio) == "COVIDhub-baseline")
geom_mean_ratios <- exp(rowMeans(log(results_ratio[, -ind_baseline]), na.rm = TRUE))
ratios_baseline <- results_ratio[, "COVIDhub-baseline"]
ratios_baseline2 <- geom_mean_ratios/geom_mean_ratios["COVIDhub-baseline"]

tab <- data.frame(model = names(geom_mean_ratios),
                  geom_mean_ratios = geom_mean_ratios,
                  ratios_baseline = ratios_baseline,
                  ratios_baseline2 = ratios_baseline2)

tab <- tab[order(tab$ratios_baseline2), ]

historical_wis <- tab %>%
  mutate(relative_wis_historical = round(ratios_baseline2, 2)) %>%
  select(model, relative_wis_historical) 
```

```{r}
inc_scores <- score_inc_historical %>%
  filter(n_locations >= 25) %>%
  filter(n_weeks >= 4) %>%
  droplevels()

# bring all timezeros to Monday:
inc_scores$timezero <- inc_scores$submission_sat

# restrict to 1-4 wk ahead state-level 
scores <- inc_scores %>% filter(horizon %in% paste(1:4),  location %in% US_fips) %>%
  filter(!is.na(score_value)) %>%
  select("model", "timezero", "location", "horizon", "score_name", "score_value") %>%
  filter(score_name %in% c("abs_error", "wis")) %>%
  pivot_wider(names_from = score_name, values_from = score_value) %>% filter(!is.na(abs_error))

# the included models:
models <- unique(scores$model)

# matrices to store:
results_ratio <- results_pval <- results_pval_fcd <- matrix(ncol = length(models),
                                                            nrow = length(models),
                                                            dimnames = list(models, models))

set.seed(123) # set seed for permutation tests

for(mx in seq_along(models)){
  for(my in 1:mx){
    pwc <- pairabs_error_comparison(scores = scores, mx = models[mx], my = models[my],
                               permutation_test = FALSE)

    results_ratio[mx, my] <- pwc$ratio
    results_ratio[my, mx] <- 1/pwc$ratio
    ## commenting these out b/c no permutation test being run
    # results_pval[mx, my] <-
    #       results_pval[my, mx] <- pwc$pval
    #     results_pval_fcd[mx, my] <-
    #       results_pval_fcd[my, mx] <- pwc$pval_fcd
  }
}

ind_baseline <- which(rownames(results_ratio) == "COVIDhub-baseline")
geom_mean_ratios <- exp(rowMeans(log(results_ratio[, -ind_baseline]), na.rm = TRUE))
ratios_baseline <- results_ratio[, "COVIDhub-baseline"]
ratios_baseline2 <- geom_mean_ratios/geom_mean_ratios["COVIDhub-baseline"]

tab <- data.frame(model = names(geom_mean_ratios),
                  geom_mean_ratios = geom_mean_ratios,
                  ratios_baseline = ratios_baseline,
                  ratios_baseline2 = ratios_baseline2)

tab <- tab[order(tab$ratios_baseline2), ]


historical_mae <- tab %>%
  mutate(historical_relative_mae = round(ratios_baseline2, 2)) %>%
  select(model, historical_relative_mae) 
```



```{r}
leaderboard_table <- inc_calibration %>%
  full_join(pairwise_scores) %>%
  full_join(historical_wis) %>%
  full_join(pairwise_scores_mae) %>%
  full_join(historical_mae) %>%
  select(model, n_forecasts_recent, relative_wis, relative_mae, n_forecasts_historical, relative_wis_historical, historical_relative_mae) %>% arrange(relative_wis) %>% 
  filter(!is.na(relative_wis) | !is.na(relative_mae) | !is.na(relative_wis_historical) | !is.na(historical_relative_mae))


datatable(leaderboard_table, rownames= FALSE, colnames = c("Model", "n recent forecasts",  "Recent rel WIS",  "Recent rel MAE","n historical forecasts" , "Historical rel WIS", "Historical rel MAE"), 
              options =  list(pageLength = 5, 
                             autoWidth = TRUE,
                             columnDefs = list(list(width = '300px', targets = "_all", render = render)), 
                             ordering = TRUE),
              filter = c("top"))
```


```{r}
inc_model_order <- leaderboard_table %>%
  arrange(-relative_wis) %>% pull(model)
```

In this table, we have included all models with an eligible WIS or MAE score. 

In order to meet eligibility for adjusted relative WIS or MAE over the most recent  `r n_weeks_eval` week period, a model must have submitted forecasts 50% or more of the evaluated forecasts in the most recent evaluation period. WIS was only calculated for teams that submitted all required quantiles. 

In order to be eligible for the historical calculation of MAE or WIS, a model must have predictions for 50% or more of the evaluated forecasts in the historical evaluation period.

### Coverage Table 

```{r}
(coverage_table  <- coverage_function(inc_calibration))
```

For inclusion in this table, a model most have contributed forecasts for 5 or more weeks total since the beginning of April, or have submitted forecasts during at least 2 out of the last 3 evaluated weeks. This inclusion criteria was applied in order to score models that submitted for a substantial amount of weeks at any point during the pandemic but may no longer be submitting, but also to evaluate new teams that have recently joined our forecasting efforts. 



<!-- ## Number of Locations -->

<!-- ```{r filters for analysis inc death} -->
<!-- n_unique_models_inc <- length(unique(score_inc_10wks$model)) #Total models submitted during this time period -->

<!--   n_models_all_weeks <- score_inc_10wks %>%  -->
<!--   group_by(horizon) %>% -->
<!--   filter(n_weeks == max(n_weeks)) %>% -->
<!--   pull(model) %>% unique() %>% length() -->

<!--  n_models_all_locations <- score_inc_10wks %>%  -->
<!--   filter(n_locations == max(n_locations)) %>% -->
<!--   pull(model) %>% unique() %>% length() -->

<!--    score_inc_10wks %>%  -->
<!--   group_by(horizon) %>% -->
<!--   filter(n_horizons == max(n_horizons)) %>% -->
<!--   pull(model) %>% unique() %>% length() -->
<!-- ``` -->

<!-- The figure below shows the number of locations that each model submitted incident death forecasts for during this evaluation period. The dates listed on the X axis are the Saturday before the first horizon. This is the Saturday associated with the target submission week. If a model is submitted on a Tuesday - Friday, the Saturday listed occurs after the submission. If the model is submitted on a Sunday or Monday, the Saturday occurs before the submission date.  -->


<!--  The number of models that submitted forecasts for all `r n_weeks_eval` weeks was n_models_all_weeks. -->

<!-- ```{r,fig.width=20, fig.height=20} -->
<!-- for_loc_figure_inc <- score_inc_10wks %>% -->
<!--   filter(score_name == "wis") %>% -->
<!--   filter(horizon == "1") %>% -->
<!--   group_by(model, submission_sat) %>% -->
<!--   summarise(n_location = n()) %>% -->
<!--   ungroup() %>% -->
<!--   group_by(model, n_location) %>% -->
<!--   mutate(n_weeks = n()) -->

<!-- for_loc_figure_inc$model <- reorder(for_loc_figure_inc$model, for_loc_figure_inc$n_weeks) -->

<!-- plot_location(for_loc_figure_inc) -->
<!-- ``` -->


## WIS components

The data in this graph has been aggregated over all locations and submission weeks. The models included have submitted forecasts for at least 50% of forecasts out of the last 10 weeks. This is the same exclusion criteria applied for WIS scores in the recent evaluation period. 

The sum of the bars adds up to the WIS score. Of note, these values may not be exactly the same as the relative WIS scores shown in the leaderboard table because these are not adjusted for weeks or locations missing. 

The data are ordered on the x axis based on their relative WIS score shown in the accuracy table. 

```{r, fig.height=8, fig.width=13}
wis_plot_function(score_inc_all, y = pairwise_scores, order = inc_model_order)
```


## Evaluation by Week  {.tabset .tabset-fade}

In the following figures, we have evaluated models across multiple forecasting weeks. The models included in this comparison must have submitted forecasts for all 50 states and at a national level for each timepoint. 

For the first 2 figures, WIS is used as a metric. The first figure shows the mean WIS across all locations for each submission week at a 1 week horizon. The second figure shows the mean WIS aggregated across locations for a 4 week horizon.

**To view a specific team, double click on the team names in the legend. To view a value on the plot, click on the point in the forecast of interest.To view a specific time of interest, highlight that section on the graph or use the zoom functionality.**

### 1 Week Horizon
```{r,fig.width=10, fig.height=6}
byweek_inc <- by_week_function(score_inc_all, var = "wis")
by_week_wis_1wk <- plot_byweek_function(byweek_inc, var = "wis", horizon_num = "1") +
  geom_hline(yintercept = .95)
ggplotly(by_week_wis_1wk, tooltip = c("label", "labelx", "labely"))
```


### 4 Week Horizon WIS

In this figure, the dotted black line represents the average 1 week ahead error. There is larger variation in error for the 4 week horizon compared to the 1 week horizon. 

```{r,fig.width=10, fig.height=6}
#calc 1 week error
meanwis_1wk <- byweek_inc %>%
  filter(horizon == "1") %>%
  group_by(target_end_date) %>%
  summarise(mean_score = mean(mean_score, na.rm = TRUE)) %>%
  mutate(model = "`average wis or 1 week horizon`",
         horizon = "4") %>%
  select(model, horizon, target_end_date, mean_score)
  
by_week_wis_4wk <- plot_byweek_function(byweek_inc, var = "wis", horizon_num = "4") +
   geom_line(data = meanwis_1wk, aes(x = target_end_date, y = mean_score), alpha=.5, color = "black", linetype = 2) +
  geom_point(data = meanwis_1wk, aes(x = target_end_date, y = mean_score), alpha=.5, size = 2, color = "black") 
ggplotly(by_week_wis_4wk,tooltip = c("label", "labelx", "labely"))
```


### 1 Week Horizon 95% Coverage

The black line represents 95% 
```{r,fig.width=10, fig.height=6}
byweek_inc <- by_week_function(score_inc_all, var = "coverage_95")
by_week_wis_1wk <- plot_byweek_function(byweek_inc, var = "coverage_95", horizon_num = "1") +
  geom_hline(yintercept = .95)
ggplotly(by_week_wis_1wk, tooltip = c("label", "labelx", "labely"))
```

### 4 Week Horizon 95% Coverage

The black line represents 95% 
```{r,fig.width=10, fig.height=6}
by_week_wis_4wk <- plot_byweek_function(byweek_inc, var = "coverage_95", horizon_num = "4") +
  geom_hline(yintercept = .95)

ggplotly(by_week_wis_4wk, tooltip = c("label", "labelx", "labely"))
```


## Evaluation by location {.tabset .tabset-fade}

This figures below show model performance stratified by location In this figure, we only include models that have submitted forecasts for all 4 horizons and at least 50% of the last 10 evaluated weeks. 

The color scheme shows the WIS score relative to the baseline. The only locations evaluated are 50 states and a national level forecast.

<!-- ### Evaluation by WIS -->
```{r, width=16, fig.height=10}
plot_by_location_wis(score_inc_10wks, order = inc_model_order)
```


<!-- ### Evaluation by MAE -->
<!-- ```{r, width=15, fig.height=11} -->
<!-- plot_by_location_mae(score_inc_10wks) -->
<!-- ``` -->


## Observed data

This plot shows the observed number of incident deaths over time in the US. The period between the vertical blue lines shows the weeks included in the "recent" model evaluations.


```{r, fig.width=8, fig.height=5}
truth_US_inc <- truth_dat_inc %>% filter(location == "US") 

plot_truth(truth_US_inc)
```
